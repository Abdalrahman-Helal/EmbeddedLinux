man -> manual of commands

echo -> The echo command is used to print text or variables to the terminal.
echo Hello, world!
doesn't need double quotation 

MyVar =5
echo $MyVar

pwd -> command in Linux stands for "print working directory"

grep -> is used to search for text patterns inside files or input
grep "error" logfile.txt  -> Search for the word "error" in a file:

grep -i -> Case-Insensitive Search
grep -v -> the -v option makes grep exclude lines that match the pattern
grep -n -> Command shows line numbers along with matching
grep -c	-> Count	      ,Prints the number of matching lines instead of the lines themselves.
grep -l	-> List filenames ,Shows the filenames that contain the matching string (one per line).
grep -L	-> List unmatched ,Shows filenames that do not contain the match.
grep -n	-> Line numbers	  ,Shows line numbers next to matching lines.
grep -h	-> Hide filename  ,	Suppresses the filename in the output (useful when searching multiple files).

ls == echo * -> list files
 
-l -> long format (shows permissions, size, owner, etc.)

-a -> all files, including hidden ones (those starting with .)

-h -> human-readable sizes (e.g., Kilo, Mega, Gigabyte instead of bytes)

-t -> It lists files sorted by modification time, newest first.

-S -> Sort by file size, from largest to smallest.

-r ->  Reverse the sorting order
        (Default ls sorts alphabetically — this makes it Z to A instead of A to Z)

-R -> Recursive listing
        Lists the contents of all subdirectories, going deep into folders.

-d ->  List directory names only, not their contents.

-i -> option shows the inode number of each file or directory.  


tree -> Display directories and files in a tree-like format
output: 
.
├── README.md
├── build
│   └── output.o
├── docs
│   └── guide.txt
└── src
    ├── main.c
    └── utils.c

tree -d -> It shows only directories, not files, in a tree structure.
.
├── build
├── docs
└── src


cd -> change directory , by default back to HOME

cd - -> go to previuos directory

mkdir -p ->  Create a directory and its parent directories if they don’t exist.
mkdir -p /home/user/projects/micromouse/code


rmdir -> Remove (delete) empty directories only.

rmdir -p (write the full path)->Remove a directory and its parent directories — but only if all are empty
rmdir -p path/to/empty/folders

file -> Determine the type of a file (not based on extension, but actual content).

mw -> rename file

rm -i ->  Delete files interactively, asking for confirmation before each deletion.
rm -r -> Recursively delete directories and their contents (files & subfolders)Recursively delete directories and their contents (files & subfolders)
rm -rf -> Forcefully and recursively delete directories and their contents — without any confirmation.

cp -> Copy files and directories.
cp -r -> copy Directory 
ex. cp file.txt backup.txt



mv -> rename files and directories

head -> Display the first few lines of a file (default is 10 lines)
head -n -> Show a specific number of lines
ex: head -n 5 file.txt
or  head -5 file.txt


tail -> Display the last few lines of a file (default is 10 lines).
tail -n 
tail -f -> Shows the last 10 lines of the file (by default).
Then keeps watching the file and displays new lines as they are added.


    cat(concatenate) 
if you have a folder containing short videos and want to conacatenate them into single movie , you can do 
cat *.mpeg > movie.mpeg    

cat -> View file content
ex: cat file.txt

cat -> Create a new file , and write content inside it , to cancel press (Hold) CTRL + D
ex : cat > newfile.txt

cat ->  Combine (concatenate) files

cat file1.txt file2.txt > combined.txt(Combine the text inside 2 files)

cat -> copy file 
ex : cat file1.txt > file2CP.txt

more -> View large text files one page at a time (read-only). 
        Displays the file page by page, useful if it’s too long to fit on one screen.
        page down by pressing SPACE

Keys while using more:
Space → next page
Enter → next line
q → quit
b → go back one pag


less -> View large text files interactively — forward & backward.
        scroll forward and backward


uptime -> how long the system has been running, along with load averages and current users.

ps -> t shows currently running processes on the system.

df -> It shows disk space usage for file systems.
df -h  -> readable format (Shows sizes in MB/GB instead of blocks.)
df -i -> command shows inode usage on your file systems

(didn't work , should have parameter i think )fdisk ->fdisk is a partitioning tool used to view, create, delete, and modify disk partitions on hard drives.
sudo fdisk -l -> Displays a list of all disks and their partitions on the system.

lsblk -> Lists all block devices (like hard drives, SSDs, USBs, SD cards), showing their structure, mount points, and sizes.

top ->  shows a real-time view of system processes, CPU/memory usage, and system load — like Task Manager in Linux.
htop -> htop is an interactive, colorful, and user-friendly alternative to top.


-----------------------------------Network--------------------------------------------

ifconfig ->  stands for interface configuration — it's used to view or configure network interfaces.

ip a -> The modern replacement for ifconfig, used to view and manage network interfaces, IPs, routes, etc.

sudo -> sudo stands for “superuser do” — it lets a regular user run commands with root (admin) privileges.

apt -> apt stands for Advanced Package Tool — it’s used to install, update, upgrade, and remove software packages.

apt search command ->Used to search for packages available in the system's repositories by name or keyword.

apt install (Package name) -> Used to install software packages from Ubuntu/Debian repositories.
apt remove (Package name) -> Used to uninstall (remove) packages, but keeps the configuration files.

nano -> nano is a simple, beginner-friendly text editor you can use right in the terminal.

vim -> vim stands for Vi IMproved — it’s a powerful terminal-based text editor, widely used by programmers and Linux admins.
to save change , Press ESC , then type :w , to quit :q  or :wq in one step

:q! -> to quit without saving changes   

--------------------------- Wild Cards ---------------------------------

--------------------------- * ---------------------------------
The * (asterisk) is a wildcard character used to match (zero) or more characters in filenames or directories.

Files starting with a: ls a*
Remove all .log files: rm *.log


rm -r -> remove all files that have a ' . ' in their name (e.g., `.txt`, `.c`, `.log`, etc.)
It will recursively delete:

All files like file.txt, main.c, data.log
Also any folders with a dot in their name (e.g., my.folder)
From the current directory

rm -r * -> remove all file and directories


--------------------------- ? ---------------------------------

The ? wildcard matches exactly (one) single character in a filename or directory name.

--------------------------- ! ---------------------------------

rm [fxh]ile.txt
file.txt , xile,txt , hile.txt will be removed 

rm [!fxh]ile.txt -> the equal not or execpt
wil remove any file doesn't contains these letters

--------------------------- [[::]]---------------------------------

[[:classname:]] matches exactly one character of that specific type.

[[:digit:]]	Matches one digit (0–9)
[[:alpha:]]	Matches one letter (A–Z or a–z)
[[:alnum:]]	Matches one letter or digit
[[:lower:]]	Matches one lowercase letter
[[:upper:]]	Matches one uppercase letter

--------------------------- {}---------------------------------
rm report.{txt,pdf,docx}
rm *.txt, *pdf, *.docx  both will work 
so {} we don’t use it 

---------------------------  \ ---------------------------------
Escape Sequence

this is file name : my?file
to delete it -> rm my\?file



-----------------------------------------------------------------

stat -> command shows detailed info (metadata) about a file or directory — more than

ln -> command is used to create links between files:

    Hard links (default)

ln -s -> Symbolic links (with -s option)
ex: ln -s ~/myfile.txt link.txt
always use relative path , using tilde symbol (Lecture 5 ,1 Hour :26 Min in vidoe )



manpath -> to know the path of manual

passwd -> to change password

whatis -> command gives you a one-line summary of what a command does — taken from the manual (man pages).

apropos-> command searches the manual pages for commands related to a keyword — like a built-in search engine for Linux commands.

apropos == man -k 

<command> -h 
<command> --help


pushd -> saves (pushes) your current directory to a stack and then changes to a new directory.

It works like a smart cd, allowing you to jump back and forth between directories easily

popd -> Pop directory off the stack and go back
dirs -> Show the directory stack


cal or ncal -> show Calendar
bc -> basic calculator 

hostname -> Displays or sets the name of your computer (host).
sudo hostname <new hostname>

uname -> Displays system information
uname -r -> Kernel release (version)
uname -n -> Network hostname
uname -m -> Machine hardware name
uname -a ->  all system info


date -> show date 

date +%D	07/10/25	
date +%F	2025-07-10	
date +%j	192 (day 192 in this year)
date +%Y	2025	
date +%m/%d/%Y	07/10/2025	
date +%m-%d-%Y	07-10-2025


wc -l = (word count) count lines only

mail ceo@company.com < CV
spell file.txt 


---------------------- Sequential Commands ----------------------

separate them with ; 

ex: echo one; sleep 5; echo two; 


---------------------- Conditonal Commands ----------------------

(Oring) || -> Run next only if previous fails
cat file1 || echo error

(Anding) && -> Run next only if previous succeeds
mkdir dir1 && cd dir1


---------------------- Loop Commands ----------------------
used in script
for file in *.txt     
 > do 
 > mv -v $file $file.old
 > done


---------------------- I/O Redirection  ----------------------

---------------------- Standard Output Redirection  ----------------------

<Commnad> >file (redirect output to file ; Overwrite)
<Commnad> >>file (redirect output to file ; Append)

echo "First line" > notes.txt
echo "Second line" >> notes.txt

cat file1 file2 > CombinedFile

ls -al usr/bin > reading.txt

1> -> Redirect stdout (normal output)
echo "Hello" > out.txt

<Commnad> 2>file (redirect error to file ; Overwrite)
<Commnad> 2>>file (redirect error to file ; Append)

2> -> Redirect stderr (errors only)
ls notfoundfile 2> error.txt

<Commnad> 1>file1 2>file2 (redirect output to file1 error to file2 ; Overwrite)
<Commnad> 1>file1 2>file2  (redirect output to file1 error to file2 ; Append)


&> -> Redirect both stdout and stderr to same file 
<Commnad> &> all_output.txt



---------------------- Standard Input Redirection  ----------------------

wc -l < file.txt
mail ceo@company.com < CV

---------------------- Common Devices for Redirection ----------------------

/dev/null	"Black hole" - discards anything written to it

command > /dev/null --> Discard normal output
command 2> /dev/null --> Discard errors only	
command &> /dev/null --> Discard both	

/dev/zero
is a special device file that provides an endless stream of zero bytes (\0) when read.
Think of it like a file filled with infinite zeros:

dev/random 
is a special device file that outputs cryptographically secure random bytes - useful for security, keys, tokens, etc

dev/unrandom 
unblocking  , y3ny bykrr el numbers 3ady

/dev/full is a special device file that:
Always returns an error when you try to write to it

Test Case : Testing write failures	See how programs behave when disk is full


----------------------------- Pipes ------------------------------
The pipe operator | lets you send the output of one command to be the input of another

<Command1> | <Command2> | <Command3>

cat log-file.log | grep "Error" , grep -> search for "Error"
cat name-list | sort


---------------------------- tee Command --------------------------
<Command> | tee <list of sinks>

ls -l | tee output.txt  ->

Shows the ls -l result on screen
AND saves it to output.txt

ls -l | tee -a output.txt -> Append to a file instead of overwriting

date | tee file1 file2 file3 file4
Passes that output into tee

tee writes it to: file1 file2 file3 file4 Also prints the output on the screen

make | tee make.out.txt >>file2 -> output goes to make.out.txt and append to file2 , but doesn't print on screen cause >> redirected to the file2

yes command with pipes 
yes | rm -r *.txt



-----------------------Arithmetic Expansion-------------------------
-----------------$(( ))--------- // always use double parentheses  (( ))   
The $((...)) syntax in Linux (Bash shell) is used for arithmetic expansion — to evaluate and compute arithmetic expressions.

echo $((5+6)) // print 11 
echo $((((5**2))*3))


----------Brace Expansion {}---------
brace expansion {} in Linux shell (like Bash) is used to generate arbitrary strings, often for ranges or repeated patterns.
echo file{1,2,3}.txt
// Ouput file1.txt file2.txt file3.txt



---------Argument Quoting--------------
---------Double Quotes " " -----------
echo "my name is $MY_name"  // my name is tom 

---------- Single Quotes ' '  ----------- 
echo 'my name is $MY_name'  // my name is $MY_name


----------- Back Quotes ` ` -------------
Back quotes (`command`) are used in the shell to execute a command and substitute its output in place.

echo "Today is `date`"
Today is Thu Jul 25 21:10:00 EET 2025

psuhd `pwd`


-------------------
tty -->The tty command in Linux/Unix tells you which terminal device you're currently using.

$ tty // output  /dev/pts/0   This means you're currently using the pseudo terminal /dev/pts/0 (common in terminal emulators or SSH sessions).

ls /dev/pts	Shows all active pseudo terminals
tty	Shows your current terminal (/dev/pts/X)

If you open 3 terminal windows and run tty in each:

    First: /dev/pts/0

    Second: /dev/pts/1

    Third: /dev/pts/2

Then ls /dev/pts will show all 3: 0 1 2 ptmx


Screen -> screen is a terminal multiplexer. It lets you:

    Create multiple terminal windows (called screens) in one terminal session.

    Detach from a session and return later-even after disconnecting.

    Run long-running processes without worrying about terminal disconnect.


CTRL + a then c	    Create a new window
CTRL + a then n	    Go to the next window
CTRL + a then p	    Go to the previous window
CTRL + a then "	    Show list of windows
CTRL + a then d	    Detach from session (can reattach later)
CTRL + a then A	    Rename the current window


screen -ls	List all active sessions
screen -r name or -r ID	Reattach a specific session by name or ID

To End a Session
Just type exit inside the session window.


echo $SHELL -> to print ur shell


type -> The type command in Linux tells you how a command name will be interpreted by the shell — whether it’s:

    a shell builtin,

    a function,

    an alias,

    or an actual file on disk (like /bin/ls).

type ls
# ls is aliased to `ls --color=auto`

type cd
# cd is a shell builtin

type grep
# grep is /bin/grep

type myfunc
# myfunc is a function


The which command in Linux shows the full path of the executable that would run if you typed a command in the terminal. 
It searches through the directories listed in the $PATH environment variable.

type rm  // output is  rm is /bin/rm
whcih rm // output is        /bin/rm    ,used in scripts 

alias -> It creates shortcuts for longer commands.
alias newCommand='LongCommand'(Make Sure no spaces)

alias ll='ls -alF'
unalias ll

alias -> to show list of all alias commands

history -> The history command in Linux shows a list of previously executed commands in the current shell session
history 10 -> show last 10 command

!! -> repeat last command you entered
!<n> -> to enter the command # n in the history 
!859 -> 

The !abc command in the Linux shell (like Bash) is a history expansion feature. It re-runs the most recent command that starts with abc.
!rm -> enter any command start with rm

script -> the script command in Linux is used to record your terminal session into a file.
script -a file -> (append the existing file)
script -t file -> (put time stamp in front of each command)
script -f file(flush after each command)


source -> The source command in Linux is used to execute commands from a file in the current shell.
source filename
or 
. filename

use case :  Run a script without starting a new shell:
source myscript.sh

Reload .bashrc or .profile after editing:
source ~/.bashrc

set -o noclobber -> Prevents overwriting existing files using >    //  Output: bash: file.txt: cannot overwrite existing file
To force overwrite, use >|:

set +o noclobber -> This disables the protection, allowing normal overwrites (default behavior):


------------- Environment Variable --------------------------
Lec:11
Normally they are all Capitial letters with " _ " as seprator

env VAR = VALUE Command , this variable will not be defined the shell it will be passed to the command as Argument
or VAR = VALUE Command 

ex: env EDITOR = vim xterm

Adding local variable in the shell 
VARIABLE = VALUE 

Add an Environment Variable 
export VARIABLE = VALUE

note: the value can be surrounded by quotes 
Optional is general 
mandatory if it contain spaces

Source_Dir = "/usr/home" -> local variable , quotes optinal 
export Project_Dir = "/my project/docs" -> Environment Variable , quotes mandatory

MyVar = 5  -> local var
to convert it to Environment Variable -> export MyVar
to convert it from environment to local -> export -n MyVar

to reset(make it 0 instead of 5) Environment variable   , export MyVar =

to remove the variale -> unset MyVar


---------- echo in Environment Variable ----------------
echo $VAR_NAME
{} are optinal , some cases are mandatory
echo $HOME_and_$USER , WRONG
echo ${HOME}_and_${USER}  , TRUE

-------------------------
printf like ehco command but uses different format 

printf "$VAR_NAME \n"
printf "String %s " $VAR_NAME
printf "Signed Decimal Numebr  %d " $VAR_NAME
printf "Floating Point Numebr  %f " $VAR_NAME

printf "$PATH \n"
printf "The path is set to  %s \n" $PATH
printf "The File Count %d \n" $FILE_COUNT


----------
set command 
set -> View all shell variables and functions

env or printenv -> print all Environment variables (Not including Local Variables)

printenv $PATH

----------------------------Commonly Used Environment Variables----------------------------------
$PATH -> Purpose: Tells the shell where to look for executable files.

Add folder to the end of $PATH
export PATH="$PATH:/home/Helal/mytools"

Add folder to the beginning of $PATH
export PATH="/home/abuhilal/mytools:$PATH"



when you type: $ binary
You're telling the shell to search for binary in the directories listed in $PATH.


when you type: $ ./binary
You're telling the shell: "Run the file named binary that's in the current directory (.)"
-----------
$DISPLAY 
When you run a graphical program (e.g. Firefox, xclock, etc.), it needs to know where to display the window.
The $DISPLAY variable tells it what screen or terminal to use.

---------------
$SHELL  -> contains the path to login shell 

------
$EDITOR -> Represent the name of default editor 

----------
$TERM -> Represent the kind of the used terminal

----------
$HOME -> home directory of current user


----------------
HISTFILE
carries the name  of the file where your shell command history is saved

HISTSIZE
carries the number of commands to remember in the command history , the default value is 500.

HISTFILESIZE
Max number of lines/commands in the history file (~/.bash_history)
---------------------------

Lec 12: Basic Text Handling 
 
>file.txt     -> redirection empty string to the file , Note that if file.txt exists, this will empty its contents (this is called truncating the file)
, if files doesn't exist it will create it and be empty file

>> file.txt   -> update timestamp only

touch file.txt -> if file exist wil update file timestamp without changing it's content

cat > filename (Overwrite) -> Terminal waits for your input. You type your content, 
then press CTRL + D to end input and save the file.
cat >> filename (Append)

sort filname -> sort line in file alphabetically
sort -r (Reverse Sort)
sort -u (don't show similar lines (unique) ) 

sort -b -> Ignore leading blanks (spaces/tabs)
Sort lines as if they start where the first non-whitespace character appears


sort -f -> Ignore case differences
Sort alphabetically, but treat A and a as the same.

sort -n -> Numeric sort
Sort based on numeric value (not ASCII value of characters).

uniq -> The uniq command in Linux filters out repeated lines 
from adjacent duplicates in a file or stream.(2 line t7t b3d 3ltol) It's often used after sort.

uniq -d -> show duplicate lines

wc -> wc stands for word count, and it's used to count lines, words, characters, bytes, and more in a file or input.

wc filename.txt
15  50 300 filename.txt

15 -> number of lines

50 -> number of words

300 -> number of bytes/characters

wc -l	Count lines only
wc -w	Count words only
wc -c	Count bytes

Comparing Text Files 

diff -> diff compares two files (or folders) and shows the differences between them.
diff file1.txt file2.txt

// compare file and directory
diff file.txt dir/   -> If dir/ contains a file with the same name as file.txt, it compares
diff file.txt dir/file.txt

diff -r dir1 dir2 -> Compares files recursively in both directories.
Shows differences in file contents and structure (i.e., missing files or folders).
Tells you which files are different, added, or only exist in one of the directories.

a stand for APPEND
c stands for CHANGE
d stands for DELETE

ex: 8a12,15  -> After line 8 in the first file, lines 12 to 15 in the second file were added
So, lines 12 to 15 exist in file2 but not in file1.


5,7c8,10 -> Lines 5 to 7 in file1 were changed to lines 8 to 10 in file2.
You’ll see these lines listed with < for file1 and > for file2 in the actual diff output.


5,7d3 -> Lines 5 to 7 in file1 were deleted to match line 3 in file2. So, file1 has extra lines 5 to 7 that don't exist in file2.

diff -> compare in normal mode 

diff -c file1.txt file2.txt
Compare two files in context format

diff -u ->unified format The diff -u command shows differences between files in unified format,
which is commonly used for code patches because it’s more compact than the context (-c) format.



Patching Directory Tree

diff -ru old-dir new-dir > patch-file

now we can use patch to update another directory with the old content
patch -p1 < patch-file



------------------------------------
Lec 13 Regular Expressions

Character Literal : 
A character literal is a regular character that matches exactly itself — no special meaning.


Metacharacter : 
A metacharacter is a special character that controls how regex behaves.
It does not match itself — it has a special function.

.	Matches any one character	a.c -> abc, a1c
*	Matches zero or more of previous	bo* -> b, booo
+	Matches one or more	go+ -> go, goo
?	Matches zero or one 
etc 
 
note :

.	Meta: Any single character
\.	Literal: A real dot .
a*	Meta: a repeated zero or more times
[.*]	Literal: Matches either . or *




BRE -> Basic Regular Expressions

--------------------- Dot . -----------------------
Matches any single character

grep ".zip" file.log   -> any character followed by zip , but will not searchig for zip only

--------------------- Ahchor ^ ,  $ ---------------
^ at the beginning of the string 
& at the end of the string 

grep "^zip" file.txt -> result any line starts with "zip"
grep "zip$" file.txt -> result any line ends with "zip"
grep "^zip$" file.txt-> result any line has only "zip"
grep "^$" file.txt -> result in empty lines 

----------------- Square Brackets [] --------------------
any char inside [] will considered as a literal char not meta char , execpt  ^ and  - 
grep "[^ab]zip" file.txt -> considered as negation , searching for any char execpt a , b or NULL char
grep "[a-z]zip" file.txt -> a to z
grep "[a-fA-F]4" file.txt -> Matches a single character in the range a–f or A–F
grep "[bg]zip" file.txt -> Matches any one character: b , g or aaabzip ...etc

Shorthand character classses 

\w	Any word character	[a-zA-Z0-9_]
\s	Any whitespace	[ \t\r\n\f\v]
\t  Stands for tab
\d	Any digit	[0-9]
\D	Any non-digit	[^0-9]

\W	Any non-word character	[^a-zA-Z0-9_]
\S	Any non-whitespace	[^ \t\r\n\f\v]

\xNN is a way to represent a character using its hexadecimal ASCII code.
\x41	A	ASCII code 0x41

---------------------- Charcacter Classes --------------
[[:alnum:]]	Letters + digits	[A-Za-z0-9]
[[:alpha:]]	Letters	[A-Za-z]
[[:digit:]]	Digits	[0-9]
[[:blank:]]	Space and tab	[ \t]
[[:lower:]]	Lowercase letters	[a-z]
[[:upper:]]	Uppercase letters	[A-Z]
[[:space:]]	Whitespace (space, tab, newline)	[ \t\n\r\f\v]
[[:xdigit:]]	Hex digits	[0-9A-Fa-f]
[[:punct:]]	Punctuation symbols	! " # $ % & ...

---------------- Extended Regular Expression -----------------
egrep or grep -E


--------------------  Alternation    |   --------------

grep -E "cat|dog" file.txt
Matches any line that contains either "cat" or "dog".

We separate theg alternbation from the rest of regular expression using () 

grep -E "^(AAA|BBB|CCC)" file.txt

----------------- Quantifiers   * , + and ? --------------

--------------------- ? --------------------------

means zero or one

grep -E "colou?r" file.txt  
Matches both: color , colour

---------------------- * -------------------- 
Zero or more repetitions

grep "go*d" file.txt
Matches:gd ,god ,good ,goood , etc.


----------------- + ---------------------
One or More
grep -E "lo+l" file.txt
Matches: lol , lool , looool , etc

---------------- Curly Brackets {} ---------------
The {} quantifier is used to specify how many times a character or group must repeat.

a{3}	Exactly 3 times	aaa
a{2,}	2 or more times	aa, aaa, aaaa
a{1,3}	Between 1 and 3 times	a, aa, aaa

ex : grep -E "a{4}" file.txt



---------------------- sed -------------------
sed -> Stream Editor
read the input file line by line 

in sed the input file can be passed through

input redirection :
sed 'Command String' < input-file

Pipes:
cat input-file | sed 'Command String'


substitution
The sed 's' command is used for substitution — i.e., replacing text in a file or input stream.
Substitute the (first occurrence) of pattern with replacement in each line

Replace "apple" with "orange" (first only per line):

sed 's/apple/orange/' file.txt

apple : pattern to search 
orange : pattern to replaced

If you're working with paths like /home/user, you'd need to escape slashes:
sed 's/\/home\/user/\/new\/path/' file.txt


You can choose another delimiter, like : or # or |:
sed 's:/home/user:/new/path:' file.txt

use global flag to avoid the only first occurrence will be substituted


searching for all occurrence of string 

sed 's/abc/(abc)/g' file.txt

Replace Matched String
sed 's/abc/(&)/g' file.txt


----------------------- awk ----------------
read the input file line by line 
awk is a powerful text-processing tool used to filter, extract, and process columns or fields in text files

performs test based on some pattern . if the test succeeds it performs an action 

Some Basic Pattern : 

No Pattern : perfom action on every line 
BEGIN : perform the action if this is the beginning of the file 
END : perfom the action if this is the end of the file



-------------------------
Lec 14 Users and Permissions

cp -p ->  used to copy files while preserving their original attributes (Permissions)

chmod -> Change File Permissions in Linux

chmod +x my-script -> add excute to all (User , Group , Other)
chmod u+w file -> add write Permission to User
chmod u-w file -> remove write Permission to User
chmod go+r file -> add read to User and Other

' = ' overwrite the old permission so remove read and write
chmod a=x file3 -> This sets execute-only (x) permission for: User (u) Group (g) Others (o)
Because a means "all", and =x means "only execute", it removes any existing r (read) or w (write) permissions.


chmod 777 file -> this mean rwx-rwx-rwx for all (User ,Group , Other)

chmod with directory

chmod -R 777 ./project-dir  , -R: recursive -> apply to the directory and all its subdirectories and files

chmod u+s file -> run the file with the User permission not the privileges of the current user
chmod g+s file -> run the file with the Group permission 

umask -> sets default permission values for newly created files and directories by subtracting permissions from the full/default values.

sticky Bit Permission 't' 

chmod +t dir1 -> in shared Directory Only the owner of a file (or root) can delete or rename it , even if others have write access to the directory.

chown -> change owner 

sudo chown tom file1 -> make file owned by user tome
sudo chown :devs file1 -> make file owned by Group devs
sudo chown tom:devs file1 -> make file owned by user tome and Group devs

sudo chown -R tom  dir-1 -> (recursive) 


chgrp -> change the owing group

sudo chgrp my-group file  

Create a basic user: 
sudo useradd tom -> Adds user tome without a home directory or password (not recommended alone).

Create user with home directory:
sudo useradd -m abdo -> Creates /home/abdo automatically.

passwd -> change your own password 
sudo passwd tom -> after adding the usr tom , you will need to setup his password

id username -> shows the user ID (UID), group ID (GID), and groups for a specific user.

who -> Lists users logged in the system 

whoami -> Display current user name

finger ->  is used to display information about system users.

userdel ->  is used to delete a user account from the system.
sudo userdel tom 

groupadd , groupdel 

sudo groupadd groupname
sudo groupdel groupname

to add user to a group
sudo useradd -G <GroupName> <UserName>

groups ->  shows the groups a user belongs to.

The su command stands for "substitute user" or "switch user".
It allows you to switch to another user account, often used to become root

su -> switch to root  
su <username> -> switch to username and keep my environment 
su -<username> -> switch to useranem and load his environment
------------------------------
Lec 15 Process Management Part 1

Process :
Definition: An independent program in execution, with its own memory space.

Thread :
Definition: A lightweight execution unit inside a process.

Think of a process as a house 🏠 and threads as people living inside it.
Building a new house (process) takes longer than adding a new roommate (thread).

to show the Process Tree Hierarchy :

pstree -> Shows processes in a tree format, starting from init or systemd.
pstree -p -> Same as above, but shows PIDs (process IDs) next to each process.
pstree 1000 -> Shows the process tree for the process with PID 1000 and all its child processes.

job -> is simply a process that the shell is managing and tracking for you
job can be 

Single Process  ex : gedit و cat file.txt

Multiple connected Processes 
ls | sort

Processes Types :

Foreground process :
Only One jon can be a Foreground
Runs interactively in the terminal.
Takes input from the user and outputs to the screen.
ex : ls , gedit

Background process :
Runs without blocking the terminal but still attached to the terminal.
You can keep using the shell while it works in the background.
Add & at the end to start in background:
ex : gedit& 

Stop a foreground job -> Press Ctrl + Z
fg -> Resume the paused job in the foreground 
Interrupt (kill) a foreground job -> Ctrl + C

sleep 100       # runs in foreground
Ctrl + Z        # stop it
fg              # resume in foreground
Ctrl + C        # interrupt and kill it


switch the foreground to the backgtound 

sleep 100       # runs in foreground
Ctrl + Z        # stop it
bg              # resume in background


jobs -> shows the list of jobs started in the current shell session and their states (in BG and FG)

switch the Background job to Foreground
jobs 
fg %n (where n is the Process Number in the list )

kill a background jon 
Kill %n 

each job has its own process group

---------------------------------------------

Lec 16 Process Management Part 2


at -> command is used to schedule a one-time task to run at a specific time in the future.

ex : at 12:00 tuesday < script

at -l 
atq     -> List Scheduled Jobs 

at -r 3 
atrm 3  -> Delete scheduled job #3


batch command is like at, but instead of running the job at a specific time
, it runs it when the system load is low (idle).

cron -> cron jobs are basically scheduled tasks that run automatically at specific times or intervals


at -> Purpose	Runs a command once at a specified time.
cron-> Runs a command repeatedly on a schedule.

at → "Do this once later."
cron → "Do this every X time.

            Min | Hour(0-23) | Day of month | Month(1-12) | Day of Week (Sunday = 0 -6)
@reboot	        (no exact time)	    Runs once after the system starts (on boot).
@yearly	        0 0 1 1 *	        Runs once a year, at midnight on Jan 1st.
@annually	    0 0 1 1 *	        Same as @yearly.
@monthly	    0 0 1 * *	        Runs once a month, at midnight on the 1st.
@weekly	        0 0 * * 0	        Runs once a week, at midnight on Sunday.
@daily	        0 0 * * *	        Runs once a day, at midnight.
@midnight	    0 0 * * *	        Same as @daily.
@hourly	        0 * * * *	        Runs once every hour, at minute 0.


crontab -l	-> List current user's cron jobs
crontab -e	-> Edit current user's crontab
crontab -r	-> Remove all cron jobs for current user


Daemon :
A daemon is a background process in an operating system that runs continuously and performs specific tasks without direct user interaction.

-------------------------------------------
Lec 17 Process Monitoring 

Set process priority

nice ->  command is used to start a process with a specific priority (niceness level).
nice value between -20 and +19
non-root users can only do 1-19 nice value

Lower niceness → higher priority (less polite).
Higher niceness → lower priority (more polite).

default nice value is 0 

nice -5 ProcessCommand -> set nice value to 5 not -5 
nice -n 5 ProcessCommand -> set nice value to 5

nice --10 ProcessCommand -> set nice value to -10
nice -n 10 ProcessCommand 

modify Process priority

renice is used to change the priority (niceness value) of an already running process

renice <priority> -p <PID>
renice 5 -p 1234 → Changes process PID 1234 to niceness 5 (lower priority).

vmstat -> display System resource usage 

xload 
tload -> System Load average (in graphical fashion)

free -> Display of memory usage (used / free )
The options:
free -k → Show in kilobytes
free -m → Show in megabytes
free -g → Show in gigabytes

free -s 1 → Runs free repeatedly every 1 second and updates the memory stats.

 
time -> Measuring running time of command 

output ->
real    0m0.005s   # total elapsed time
user    0m0.001s   # CPU time in user mode
sys     0m0.002s   # CPU time in kernel mode

uptime -> Measuring system uptime

ps -> Display info about processes under the current shell

ps -e -> Display all processes in the system

ps -A -> Display all processes in the system
Shows all processes on the system, including those without a terminal (daemons, background services, etc.).


ps a -> Display all processes in the system except those which are not attached with a terminal
Shows all processes with a terminal (TTY), including ones from other users.


ps ax -> Display all processes in the system including those which are not attached with a terminal

ps -f (full format)
Shows extra details like UID, PID, PPID, start time, TTY, time, and command.

ps -F (extra full format)
Shows everything in -f plus more memory-related info (SZ, RSS, PSR, etc.).

ps -o pid,ppid,pgid,sid,command -> This ps command is using custom output format with -o to show specific process inf


ps auxf is just combining multiple ps options:

a → Show processes for all users that have a terminal.
u → Long format ,Display user-oriented output (user, %CPU, %MEM, etc.).
x → Include processes without a controlling terminal (e.g., daemons) , remove tty restriction.
f → Show process hierarchy in a tree format.

showing Threads


ps -H → Show processes in a hierarchy (tree) format.
Similar to ps f but uses indentation instead of tree lines.

ps -L → Show threads of processes.
Displays LWP (Light Weight Processes), which are basically threads inside processes.

ps -T → Show threads for the calling terminal’s processes.
Similar to -L but scoped to the current terminal session only.

ps -m → Display threads after processes (by process).
the process is shown first, then its threads listed underneath.


top -> displays dynamic view of the resource usage of the system processes

Useful keys while top is running
Key	Action

q	Quit top
P	Sort by CPU usage
M	Sort by Memory usage
T	Sort by Time+ (total CPU time)
k	Kill a process — will ask for the PID
r	Renice (change priority) of a process
h	Show help


----------------------------

Lec 18 Process Life-Cycle

Fork and Execute

Zombie State


---------------------------------------- 

Lec 19 Using Signals


kill -l -> listing singals Names and Numbers
kill command used in passing signal to process using SignalNumber
kill <pid>
if no singal specified , default is SIGTERM (signal terminate)

kill -<SignalNumber> <pid>
kill -9 1185 -> passing singal number 9 to PID (1185)
kill SIGKILL 1185


killall <Singal><Command Name>
if no singal specified , default is SIGTERM (signal terminate)
killall kills processes by their name instead of their PID.
ex :    killall firefox ->  Kill all processes named "firefox"



Match user processes only
pkill -u ahmed firefox
Kills firefox only for user ahmed.


pkill -P 2345
This leaves the parent process alive but terminates its children.


pkill -u tom -> send a SIGTERM to all processes owned by user tom

pkill SIGSTOP -t tty1 -> send SIGSTOP to all processes running under tty1 terminal

pkill -P 1107 -> send SIGTERM to all children of process with pid 1107



xkill is a Linux command used in graphical environments (like GNOME, KDE, XFCE) to force-close a window by clicking on it.
Click on a frozen Firefox window → the Firefox process ends immediately.


keyboard hot keys

CTRL + C -> SIGINT
CTRL + Z -> SIGTSTP
CTRL + \ -> SIGQUIT


SIGHUB (Signal Hang Up)-> Originally sent to a process when its controlling terminal was closed or disconnected (like hanging up a modem back in the day 📞).

SIGINT (Signal Interrupt) -> Sent to a process to interrupt it (stop execution).
Usually when you press Ctrl + C in the terminal where the process is running.


SIGQUIT -> Like SIGINT, but it also creates a core dump before stopping the process — useful for debugging.
Usually when you press Ctrl + \ in the terminal.

SIGILL (Signal Illegal Instruction) ->  Sent to a process when it tries to execute an invalid, unknown, or privileged CPU instruction.
Terminates the process and creates a core dump (for debugging).

SIGABRT (Signal Abort)-> Sent to a process to abort it — usually generated by the process itself when it detects a fatal error.
terminates the process and creates a core dump (for debugging).

SIGTRAP -> Sent to a process when a trap (debugging breakpoint or special trace event) occurs.
Terminates the process and produces a core dump.

SIGFPE (Floating Point Exception.) -> Sent to a process when it performs an erroneous arithmetic operation.
Terminates the process and produces a core dump.

SIGKILL ->  Immediately terminates a process.
Kill without cleanup — the process is removed from memory instantly.

SIGKILL can't ignore , catch , block

SIGSTOP -> Immediately pauses (stops) a process.
Stop the process until it receives SIGCONT.
Cannot be caught, blocked, or ignored.


SIGTSTP ->  Pause a process from the terminal — “Terminal Stop”.
Stop the process, but can be caught or ignored by the process.
usually triggered: Pressing Ctrl + Z in the terminal.

SIGSTOP & SIGTSTP waitng SIGCONT to resume operation



SIGTERM
Signal number: 15 (default for kill)
Purpose: Politely asks a process to terminate.
Default action: End the process.
Catchable? ✅ Yes — the process can trap it, do cleanup, and even ignore it.


--------------------------- 

Lec 20 Networking in Linux Part 1

MAC address 
IP address 
Subnet address
Subnet Mask
NAT (Network Address Tanslation)
Domain Names

ifconfig -> showing and managing interface 

sudo ifconfig eth0 up  -> This will enable the eth0 interface.
sudo ifconfig eth0 down -> disables the interface.

ifconfig -s -> abstract description


route -> command is used to view and configure the system’s IP routing table


route add <address> dev <interface> gw <address> 
route add default gw <address> 
route del <address> 
route del default 

To add a route
sudo route add 192.56.76.123 dev eth1 gw 192.168.101.1 
sudo route add -net 192.56.76.0 netmask 255.255.255.0 dev eth0 
sudo route add default gw 192.168.101.1 

to Delete a route

sudo route del default
sudo route del 192.168.100.20

ARP (Address Resolution Protocol) → Translates an IP address into a MAC address inside a local network.

ARP -> command is responsible for display and management of the ARP table

arp -> display ARP table

arp -s -> Manually add a static ARP entry (IP-to-MAC mapping) to the ARP cache.
sudo arp -s <IP_address> <MAC_address>
ex : sudo arp -s 192.168.1.10 00:11:22:33:44:55

arp -d → Deletes an ARP entry (removes an IP-to-MAC mapping) from the ARP cache.
ex :sudo arp -d 192.168.1.10


---------------------------

Lec 21 Networking in Linux Part 2



ping command → Sends ICMP Echo Request packets to a host to test network connectivity and measure response time.
ex : ping google.com
It keeps sending packets until stopped (Ctrl + C).

For a fixed number of pings:
ping -c 4 google.com


TTL (Time To Live) in ping → a value in the packet header that tells how many hops (routers) the packet can pass through before being discarded.
Every router it passes decreases TTL by 1
If TTL reaches 0, the packet is dropped, preventing infinite loop


traceroute -> same as ping  , but this tiome , you get the whole route of the packet 

netstat in Linux → shows network connections, routing tables, interface statistics, and more.

netstat -a → show all connections (listening + established).
netstat -t → show only TCP connections.
netstat -u → show only UDP connections.
netstat -r → show routing table.
netstat -i → show network interfaces info.
netstat -ie → shows detailed information about all network interfaces (like ifconfig output)


to list statistics on socket of different Protocols:
netstat -s 
netstat -st -> TCP
netstat -su -> UDP


netstat -rnC 

-r → Show the kernel routing table.
-n → Show numeric addresses (don’t resolve hostnames).
-C → Not a standard netstat option on most Linux systems; in some versions it shows the routing

telnet -> sed to connect to a remote host over TCP, usually for testing connectivity or accessing a service.

telnet <desination Address>


ftp → File Transfer Protocol client used to connect to an FTP server to upload, download, or manage files.
ftp <desination Address>

get report.pdf
Downloads report.pdf from the server to your local machine.

put myfile.txt
Uploads myfile.txt from your local machine to the server.


mget *.txt → Download multiple files matching a pattern.
mput *.jpg → Upload multiple files matching a pattern.

bye → Exit the FTP session.

SSH (Secure Shell) protocol → A network protocol used to securely access and manage remote systems over an unsecured network.
like the telnet but secured
ex : ssh root@192.168.1.10

scp (Secure Copy) → Copies files between local and remote systems securely over SSH

scp [options] source destination

scp , Local to Remote
scp file.txt user@remote_host:/path/to/destination/

scp , Remote to Local
ex: scp user@remote_host:/path/to/file.txt /local/destination/

SFTP (SSH File Transfer Protocol) → A secure way to transfer files over SSH, similar to FTP but encrypted.
same commands as FTP
ex : sftp root@192.168.1.10

wget → A Linux command-line tool to download files from the internet via HTTP, HTTPS, or FTP.

ex : wget https://example.com/file.zip

ssh -X → Enables X11 forwarding over SSH,
allowing you to run graphical applications on a remote Linux machine and display them on your local machine.

VNC

----------------------------

Lec 22 Package Management

ldd (List Dynamic Dependencies) → shows which shared libraries a program or executable uses.

ldd <program>
ex : ldd /bin/ls

ldconfig → command updates the system’s shared library cache so programs can find the libraries they need.

Reads library directories (from /etc/ld.so.conf and /etc/ld.so.conf.d/).
Updates the /etc/ld.so.cache file with the paths to shared libraries.
Links library files (e.g., .so files) in standard locations.

to build cache with addition of /usr/local/lib
ldconfig /usr/local/lib

ldconfig -p → lists all the shared libraries currently known to the dynamic linker, along with their full paths.

dpkg → Debian package manager used to install, remove, and manage .deb packages on Debian-based systems (like Ubuntu).


dpkg -i package.deb	-> Install a .deb package
dpkg -r package_name -> Remove a package (keep config files)

dpkg -l 
dpkg --list → Lists all installed packages on a Debian-based system in a table format.
dpkg -L package_name -> Show files installed by a package

apt stands for Advanced Package Tool
— a package manager used in Debian-based Linux distributions like Ubuntu.

sudo apt install package_name   # Install a package
sudo apt remove package_name    # Remove a package
sudo apt update → Downloads the latest package lists from repositories so your system knows about the newest versions available.
(It doesn’t install or upgrade anything, just updates the local index.)
sudo apt upgrade → Actually upgrades the installed packages on your system to the newest versions found in the updated package list.

lsb_release -sc prints the codename of your Linux distribution release.
add-apt-repository is used to add or remove a software repository (PPA or other APT source) to your system’s sources list.

Add
ex : sudo add-apt-repository ppa:graphics-drivers/ppa
Remove 
ex : sudo add-apt-repository --remove ppa:graphics-drivers/ppa

After adding, you usually run:
sudo apt update 
to refresh the package list.

sudo apt dist-upgrade works like apt upgrade but it’s smarter:

sudo apt upgrade → Upgrades packages without removing anything. 
If a package needs a dependency change that would require removal of another package, it skips it.

sudo apt dist-upgrade → Upgrades packages and can install or remove packages if needed to complete the upgrade 
(used for bigger updates, like kernel changes or distro upgrades).

In short:
upgrade = safe, no removals.
dist-upgrade = can add/remove to fully upgrade.


sudo apt check ->  verifies the system’s package dependencies.

It:
Checks if installed packages have all required dependencies.
Reports any broken or missing dependencies.
Doesn’t install or remove anything — it’s just a diagnostic.

sudo apt remove <package> ->  removes the installed package but keeps its configuration files.
sudo apt purge <package> -> (removes package + config files)

sudo apt autoremove -> automatically deletes unused packages that were installed as dependencies but are no longer required by any installed software.

apt-cache search <keyword> -> lets you search your local APT package database using keywords found in package names or descriptions
format : apt-cache search <search-term> 
ex : apt-cache search vsftpd

apt-cache show <package> ->  displays detailed information about a package from your local APT cache, without installing anything
Output includes: version , size , dependencies , conflicts

apt-cache pkgnames ->  lists all package names in your local APT cache database

apt-cache policy <package> ->get the policy of the package  Main , Restricted , Universe , Multiverse

sudo apt autoclean -> Removes the .deb files for package from /var/cache/apt/archives  that are no longer needed

sudp apt clean -> Remvoes all .deb files form /var/cache/apt/archives


------------------------------------

Lec 23 Searching For Files

which -> command in Linux shows the full path of the executable (Binary) file that will be run when you type a command.
this command searching for (Binary Files) using $PATH environment

locate or mlocate -> command in Linux quickly finds the paths of files and directories by searching a prebuilt database.
but it may miss very recent files unless you update the database with:
sudo updatedb

ex : locate ib/zi
output : /usr/lib/zip
/usr/lib/zip/include/zip.h
/usr/lib/zip/libzip.so


find -> command in Linux is used to search recusively in all sub directories for files and directories in a directory hierarchy based on 
name
size
type
permissions
modification date and more.
or combination of all of those

find ~ -> command searches your home directory (because ~ expands to /home/yourusername) 
and lists everything inside it and its subdirectories.

find /bin /sbin /usr/bin -> Here you’re telling find to search in three different directories:

/bin → basic essential commands
/sbin → system administration commands
/usr/bin → most user-level commands

searchig by Type
in find you can search by file type using the -type option.

Common types:
f → regular file
d → directory
l → symbolic link
c → character device
b → block device
p → named pipe
s → socket

format : find <scope> -type <type>

examples :
Find only files in /usr/bin:
find /usr/bin -type f

Find only directories in /etc:
find /etc -type d

find all symbolic links in /bin:
find /bin -type l


Find character devices in /dev:
find /dev -type c

searchig by file name
format : find <scope> -name <FileName>

examples : 

Find a file exactly named test.txt in your home directory:
find ~ -name "test.txt"

Case-insensitive search for test.txt:
find ~ -iname "test.txt"

Find all .c files under /usr/src:
find /usr/src -name "*.c"

Find all files whose names contain xml anywhere:
find /etc -name "*xml*"



searchig by file size
format : find <scope> -size <file size filter>
b → block (512 byte) this is the default , if no unit is passed
c → bytes
w → word (2Bytes)
k → kilobytes
M → megabytes
G → gigabytes

Find files larger than 10 MB in /var/log
find /var/log -size +10M

Find files smaller than 500 KB in /home
find /home -size -500k

Find files exactly 100 bytes in /tmp
find /tmp -size 100c

Find files between 1 MB and 5 MB
find / -size +1M -size -5M

searching by permission 

Find files with exactly 644 permissions in /etc
ex :find /etc -perm 644

searching by user 
format find <path> -user <username>
ex : find /etc -user root

searching by modification time 
sudo find / -mtime -50  -> find files modified less than 50 days ago.
sudo find / -atime +50  -> find files that were last (accessed) more than 50 days ago.

using Multiple "ANDed" filters

Find all .log files bigger than 5 MB in /var/log
ex : find /var/log -name "*.log" -size +5M

using ' -a ' to separate 
ex : find /var/log -name "*.log" -a -size +5M

using '-and' to separate
ex : find /var/log -name "*.log" -and -size -500k


using Multiple 'ORed' Conditions   

Find files ending with .log OR .txt in /var/log:
using '-o'
ex :find /var/log -name "*.log" -o -name "*.txt"

using '-or'
ex :find /var/log -name "*.log" -or -name "*.txt"

Inverting Conditions

using '!'
find everything NOT named file.txt in your home:
ex : find ~ \! -name "file.txt"

using '-not'
ex : find /home -not -name "*.txt" 


find & perfom Action

the default action for the find command is to print the list of files matching the search criteria 

Actions :

Print :
ex : find ~ -type d -print

Delete :
ex : find /home -name "*.tmp" -delete

Detailed List:
ex : find ~ -size +10M -ls

stop searching immediately after the first match is found:
ex :find /etc -name "hosts" -quit   or  find /etc -name "hosts" -print -quit


-prune : to exclude directories (or files) from the search (Skip):
ex :find ~ -type l -prune -o -name "*.txt" -print
    find . -path ./misc -prune -o -name '*.txt' -print
    find . -type d \(-path dir1 -o -path dir2 -o -path dir3 \) -prune -o -print


-exec option in the find command lets you run another command on each found file.
Syntax: find <path> <conditions> -exec <command> {} \;
{} → placeholder replaced by the current file found
\; → ends the -exec command (must be escaped)

ex : find . -name "*.pdf" -exec ls -l {} \;
ex : find . -name "*.txt" -exec cp {} {}.new \;


-ok -> -ok option in find is exactly like -exec, but safer.
It will ask for confirmation before running the command on each matched file.


ex : find . -name "*.old" -ok mv {} {}.new \;

\;   vs     +

With -exec ... \; -> executes the command once per file. (deleting file by file)
With -exec ... + -> executes the command once with as many files as possible (batch mode). (delete all files one time)

-regex option in find -> -regex lets you filter files by a regular expression that matches the entire path (not just the filename).

Finds files with names like 123.log, 456.log in any subdirectory.
ex : find . -regex '.*/[0-9]+\.log'




