#bash scripiting command 

Backticks execute a command and store its output into a variable.
ex: length=`echo $str | wc -c`

read -p -> is used to prompt the user for input on the same line.
ex:
read -p "Enter your name: " name
echo "Hello, $name!"



read -s -> the -s option with read makes the input silent — meaning it doesn’t show what the user types (useful for passwords).
ex: 
read -s -p "Enter your password: " password
echo
echo "Password entered."




set -x → turns debug mode ON
It makes the shell print each command before executing it, with all variable values expanded.
Useful for seeing what your script is actually doing step by step.

set +x → turns debug mode OFF
You use this to stop showing those trace lines.


test -f file.txt

if [ -f "./test.sh" ]
then
    echo "File Exist"
else
    echo "File Doesn't Exist"
fi

OR in one line : 
test -f "./test.sh" && echo "File Exist" || echo "File Doesn't Exist"


Arguments
$$ -> Prints the Process ID (PID) of the current shell running the script.
ex: echo "PID of this script: $$"

echo $0 -> Prints the name of the script.
echo $1
echo $3 -> Prints the first and third arguments passed to the script.

echo $# -> Prints the number of arguments passed to the script.

echo $@ -> Prints all arguments as separate words.

echo $* -> Prints all arguments as a single string. 

echo $? ->  Check last command : 0 means success else error
            Prints the exit status of the last command
            Since it failed, $? will be non-zero (usually 127 for command not found).



$@ ->  Represents all arguments passed to the script, preserving spaces


        $@     vs     $*
Example: ./script.sh one "two three" four


"$@" → preserves argument boundaries.  OUTPUT : one
                                                two three
                                                four
                                                
"$*" → combines everything into a single string.  OUTPUT: one two three four



#Arguments with array 
args=("$@")       # Store all script arguments into an array called args
echo "arguments to the shell"
echo ${args[0]} ${args[1]} ${args[2]}   # Print first three arguments




Always quote variables unless you have a specific reason not to
"$var" -> Protects spaces, tabs, and special characters.
ex: 
name="Hello World"
echo $name     # ❌ prints: Hello World → may break commands
echo "$name"   # ✅ prints: Hello World safely



Strings

IFS=',' -> It tells Bash: “Whenever you split text, split on a comma.
IFS = Internal Field Separator




read -ra ADDR <<<"$str" 

read       → reads input and splits it using the current IFS
-r         → don’t escape backslashes
-a ADDR    → store the split values in an array called ADDR
<<< "$str" → here-string → Means: “Give the value of $str to the read command as input”


What does @ mean inside ${ADDR[@]} 
the @ symbol tells Bash: Expand all elements of the array, each element as a separate word.

ex: ADDR=("A" "B" "C")
    echo "${ADDR[@]}"       -> A B C    #Each value is separate.